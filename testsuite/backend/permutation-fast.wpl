let testp = {  0,  3,  6,  9, 12, 15, 18, 21
            , 24, 27, 30, 33, 36, 39, 42, 45
            ,  1,  4,  7, 10, 13, 16, 19, 22
            , 25, 28, 31, 34, 37, 40, 43, 46
            ,  2,  5,  8, 11, 14, 17, 20, 23
            , 26, 29, 32, 35, 38, 41, 44, 47
            }


let zeros = { '0,'0,'0,'0,'0,'0,'0,'0 
            , '0,'0,'0,'0,'0,'0,'0,'0 
            , '0,'0,'0,'0,'0,'0,'0,'0 
            , '0,'0,'0,'0,'0,'0,'0,'0 
            , '0,'0,'0,'0,'0,'0,'0,'0 
            , '0,'0,'0,'0,'0,'0,'0,'0 
            }


fun perm8(p : arr[8] int, iarr : arr[8] bit) {
  var oarr : arr[48] bit := zeros;

  -- Slow when run like this, hopefully fast when autolutted
  for j in [0,48] {
    for i in [0,8] {
       if j == p[i] then { 
           oarr[j] := iarr[i]; 
       }
    }
  }
  return oarr;
}

fun vector_or(a1 : arr[48] bit, a2 : arr[48] bit) {
  var res : arr[48] bit := zeros;
  for i in [0,48]
    res[i] := a1[i] | a2[i];
  return res;
}

       
fun perm(p : arr[48] int, iarr : arr[48] bit) {
  var oarr    : arr[48] bit := zeros;
  var oarrtmp : arr[48] bit := zeros;

  var iarr1 : arr[8] bit := {'0, '0, '0, '0, '0, '0, '0, '0};

  for j in [0,6] {
     let p1 = p[j*8,8];
     iarr1 := iarr[j*8,8];
     oarr := vector_or(oarr,perm8(p1,iarr1));
  }
  return oarr;
}
  
let comp main = read[bit] >>> 
repeat { x <- takes 48
       ; emits (perm(testp,x))
       } >>> write[bit]


